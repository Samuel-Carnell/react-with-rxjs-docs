(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{369:function(e,t,s){"use strict";s.r(t);var a=s(45),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"core-concepts"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#core-concepts"}},[e._v("#")]),e._v(" Core Concepts")]),e._v(" "),s("h2",{attrs:{id:"push-vs-pull"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#push-vs-pull"}},[e._v("#")]),e._v(" Push vs Pull")]),e._v(" "),s("p",[e._v("Historically, React uses a pull-based architecture. This means that when React needs to re-render, it will call the render function of every affected component. This will return a new representation of the UI, which React can reconcile with the previous one. Any changes are then propagated to the DOM.")]),e._v(" "),s("p",[e._v("This kind of behavior is called pull because the consumer (in this case, React), is the one that requests the new value.")]),e._v(" "),s("p",[e._v("On the other hand, RxJS uses a push-based approach, where you declaratively define streams and their relationships, and RxJS will propagate every change from one stream to the next one.")]),e._v(" "),s("p",[e._v("This is called push because now the producer of the state is responsible for pushing the new value over to those that are subscribed to it. This benefit of this is that only those entities that depend on the value that has changed will update, and it can be done without having to make comparisons or detect changes.")]),e._v(" "),s("p",[e._v("Not only can this approach significantly improve performance, it also makes state management more declarative, in a way that can be read top-to-bottom.")]),e._v(" "),s("h2",{attrs:{id:"enhanced-unidirectional-data-flow"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#enhanced-unidirectional-data-flow"}},[e._v("#")]),e._v(" Enhanced unidirectional data flow")]),e._v(" "),s("p",[e._v("Both React and RXJS are design with unidirectional data flow in mind. State is owned by some component or observable, which more complex data structures can be derived from. This process can be repeated multiple times until you eventually end up with a complete UI.")]),e._v(" "),s("p",[e._v("However unlike React, RXJS utilizes it's asynchronous nature to take this one step further. Take this example")]),e._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" selectedUserId$ "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Subject")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("const")]),e._v(" selectedUser$ "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" selectedUserId$"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("pipe")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("\n  "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("mergeMap")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("userId")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=>")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("from")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("fetchUser")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("userId"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\nselectedUser$"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("subscribe")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("...")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),s("p",[e._v("Given that RXJS uses a push based architecture, it doesn't matter when the selected user is returned, just that is pushed on to those that are subscribed to it. This contrasts with React in which the selected user would typically be store in the components state and, updated it through an effect running when the selected user id is updated.")]),e._v(" "),s("h2",{attrs:{id:"concurrent-mode-safety"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#concurrent-mode-safety"}},[e._v("#")]),e._v(" Concurrent mode safety")]),e._v(" "),s("p",[e._v("With the introduction of concurrent mode, React can work on several renders concurrently. These renders take an unpredictable amount of time to complete or can be abandoned completely.")]),e._v(" "),s("p",[e._v("To ensure ReactXJS is compatible with React concurrent mode, observables must be subscribed to as a side effect of the rendering process. So that only a single subscription is established after the render is committed to the screen.")]),e._v(" "),s("p",[e._v("The consequence of this is that the "),s("code",[e._v("useLatestValue")]),e._v(" hook must return a default value on the initial render, even if the observable emits values synchronously. In cases where the source observable does emit values synchronously ReactXJS will prevent any screen tearing, however the hook must still return a default value.")])])}),[],!1,null,null,null);t.default=n.exports}}]);