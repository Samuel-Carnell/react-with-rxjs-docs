(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{369:function(e,t,a){"use strict";a.r(t);var s=a(45),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"optimized-renders"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#optimized-renders"}},[e._v("#")]),e._v(" Optimized renders")]),e._v(" "),a("p",[e._v("Everyone knows that React will rerender when state is updated. It's a reasonable assumption that if the state has changed then the UI will be changed as well. Although this isn't always the case. Components don't just declare the UI that should be render, they also schedule any work that needs to be done after the UI has rendered, also know as effects.")]),e._v(" "),a("p",[e._v("A state update can result in the same UI being generated but schedule side effects to run after. These side effects usually go on to perform some asynchronous task which cause another state update that that actually results in a UI change e.g calling an api when the component is mounted and storing the response in state.")]),e._v(" "),a("p",[e._v("This first render is quite wasteful, the UI hadn't changed and it only resulted in a side effect being scheduled.")]),e._v(" "),a("p",[e._v("React with RXJS directly addresses this issue of wasteful renders. By declaring streams of data, instead of state. These streams of data can be triggered by the same callbacks that would trigger state updates but more importantly they can go on to perform asynchronous tasks that then rerender the component when complete. Avoiding the first wasteful render, and only rendering when state that actually affects the UI has changed.")])])}),[],!1,null,null,null);t.default=n.exports}}]);